diff --git a/PXE/Tests.module b/PXE/Tests.module
index e69de29..5d3fea4 100644
--- a/PXE/Tests.module
+++ b/PXE/Tests.module
@@ -0,0 +1,6 @@
+/mytest 1 10
+/mytest 10
+/mytest 7 1
+/mytest 1 100
+/threads
+/readythreads
\ No newline at end of file
diff --git a/lab1.txt b/lab1.txt
new file mode 100644
index 0000000..3cd6ab4
Binary files /dev/null and b/lab1.txt differ
diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
index cec924b..f76b5d7 100644
--- a/postbuild/paths.cmd
+++ b/postbuild/paths.cmd
@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
 set PATH_TO_VM_TOOLS=__EMPTY__
 set VOL_MOUNT_LETTER=__EMPTY__
 
+if _%COMPUTERNAME%_==_DESKTOP-MGL16OR_ goto config_DESKTOP-MGL16OR
 if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
 if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
 if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
@@ -69,4 +70,14 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
 
 goto end
 
+:config_DESKTOP-MGL16OR
+
+SET VOL_MOUNT_LETTER="Q:"
+SET PATH_TO_VM_FILE="C:\Users\40783\Dropbox\My PC (DESKTOP-MGL16OR)\Desktop\HAL9000folder\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
+SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware Workstation"
+SET PXE_PATH="C:\Users\40783\Dropbox\My PC (DESKTOP-MGL16OR)\Desktop\HAL9000folder\HAL9000\PXE"
+SET PATH_TO_VM_DISK="C:\Users\40783\Dropbox\My PC (DESKTOP-MGL16OR)\Desktop\HAL9000folder\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
+SET PATH_TO_LOG_FILE="C:\Users\40783\Dropbox\My PC (DESKTOP-MGL16OR)\Desktop\HAL9000folder\HAL9000\VM\HAL9000_VM\HAL9000.log"
+goto end
+
 :end
\ No newline at end of file
diff --git a/src/HAL9000/headers/cmd_basic.h b/src/HAL9000/headers/cmd_basic.h
index 635acd3..4b6b804 100644
--- a/src/HAL9000/headers/cmd_basic.h
+++ b/src/HAL9000/headers/cmd_basic.h
@@ -13,3 +13,5 @@ FUNC_GenericCommand CmdSetLogComponents;
 FUNC_GenericCommand CmdClearScreen;
 FUNC_GenericCommand CmdRunAllFunctionalTests;
 FUNC_GenericCommand CmdRunAllPerformanceTests;
+FUNC_GenericCommand CmdMyTest;
+FUNC_GenericCommand CmdReadyThreads;
diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
index be2588a..44f055f 100644
--- a/src/HAL9000/headers/thread_internal.h
+++ b/src/HAL9000/headers/thread_internal.h
@@ -89,6 +89,8 @@ typedef struct _THREAD
     // MUST be non-NULL for all threads which belong to user-mode processes
     PVOID                   UserStack;
 
+    TID                   parentTh;
+
     struct _PROCESS*        Process;
 } THREAD, *PTHREAD;
 
diff --git a/src/HAL9000/src/cmd_basic.c b/src/HAL9000/src/cmd_basic.c
index 312b097..d4cc492 100644
--- a/src/HAL9000/src/cmd_basic.c
+++ b/src/HAL9000/src/cmd_basic.c
@@ -153,3 +153,114 @@ void
 
     TestRunAllPerformance();
 }
+typedef struct _MY_ENTRY
+{
+    LIST_ENTRY ListEntry;
+    DWORD Value;
+
+} MY_ENTRY,*PMY_ENTRY;
+
+static
+STATUS
+(__cdecl _MyListFunction) (
+    IN      PLIST_ENTRY     ListEntry,
+    IN_OPT  PVOID           FunctionContext
+    )
+{
+    UNREFERENCED_PARAMETER(FunctionContext);
+    PMY_ENTRY pMyEntry = CONTAINING_RECORD(ListEntry, MY_ENTRY, ListEntry);
+
+    LOG("%d ", pMyEntry->Value);
+
+    return STATUS_SUCCESS;
+}
+
+void
+(__cdecl CmdMyTest)(
+    IN    QWORD     NumberOfParameters,
+    IN    char* Param1,
+    IN    char* Param2
+
+    )
+{
+    DWORD dwMin, dwMax;
+    LIST_ENTRY head;
+    PMY_ENTRY pMyEntry;
+    LIST_ITERATOR iterator;
+    PLIST_ENTRY pListEntry;
+
+    dwMin = dwMax = 0;
+    pMyEntry = NULL;
+
+    if (NumberOfParameters == 1)
+    {
+        LOG("The number of parameters is 1, the first parameter is %s.\n", Param1);
+        atoi(&dwMax, Param1, 10, FALSE);
+        dwMin = 1;
+    }
+    else if (NumberOfParameters == 2)
+    {
+        LOG("The number of parameters is 2, the parameters are %s and %s.\n", Param1, Param2);
+        atoi(&dwMin, Param1, 10, FALSE);
+        atoi(&dwMax, Param2, 10, FALSE);
+    }
+
+    if (dwMin > dwMax)
+    {
+        dwMax ^= dwMin;
+        dwMin ^= dwMax;
+        dwMax ^= dwMin;
+
+    }
+
+    InitializeListHead(&head);
+
+    for (DWORD dwIndex = dwMin; dwIndex < dwMax; dwIndex++)
+    {
+        pMyEntry = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(MY_ENTRY), HEAP_TEST_TAG, PAGE_SIZE);
+        if (pMyEntry == NULL)
+        {
+            LOG_FUNC_ERROR("EXAllocatePoolWithTag", STATUS_HEAP_INSUFFICIENT_RESOURCES);
+            return;
+        }
+        pMyEntry->Value = dwIndex;
+
+
+        if (pMyEntry->Value % 2 == 0)
+        {
+            InsertTailList(&head, &pMyEntry->ListEntry);
+        }
+        else
+        {
+            InsertHeadList(&head, &pMyEntry->ListEntry);
+        }
+    }
+
+    for (PLIST_ENTRY pEntry = head.Flink; pEntry != &head; pEntry = pEntry->Flink)
+    {
+        pMyEntry = CONTAINING_RECORD(pEntry, MY_ENTRY, ListEntry);
+        LOG("%d ", pMyEntry->Value);
+    }
+    LOG("\n");
+
+    ListIteratorInit(&head, &iterator);
+
+    while ((pListEntry = ListIteratorNext(&iterator)) != NULL)
+    {
+        pMyEntry = CONTAINING_RECORD(pListEntry, MY_ENTRY, ListEntry);
+        LOG("%d ", pMyEntry->Value);
+    }
+    LOG("\n");
+
+    ForEachElementExecute(&head, _MyListFunction, NULL, FALSE);
+
+    LOG("\n");
+
+    while (!IsListEmpty(&head))
+    {
+        pListEntry = RemoveHeadList(&head);
+        pMyEntry = CONTAINING_RECORD(pListEntry, MY_ENTRY, ListEntry);
+        ExFreePoolWithTag(pMyEntry, HEAP_TEST_TAG);
+    }
+}
+
diff --git a/src/HAL9000/src/cmd_interpreter.c b/src/HAL9000/src/cmd_interpreter.c
index d0b254f..6728ffc 100644
--- a/src/HAL9000/src/cmd_interpreter.c
+++ b/src/HAL9000/src/cmd_interpreter.c
@@ -106,6 +106,10 @@ static const COMMAND_DEFINITION COMMANDS[] =
     { "rangefail", "Causes a range check failure to assert", CmdRangeFail, 0, 0},
     { "bitecookie", "Causes a GS cookie corruption to assert", CmdBiteCookie, 0, 0},
 
+    {"mytest","Performs a simple test", CmdMyTest, 1,2},
+
+    {"readythreads","Prints the threads in the ready list.", CmdReadyThreads, 0,0},
+
     { "help", "Displays this help menu", _CmdPrintHelp, 0, 0}
 };
 
diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
index f794c95..11544d4 100644
--- a/src/HAL9000/src/cmd_thread_helper.c
+++ b/src/HAL9000/src/cmd_thread_helper.c
@@ -73,6 +73,8 @@ _CmdReadAndDumpCpuid(
 
 static FUNC_ListFunction _CmdThreadPrint;
 
+static FUNC_ListFunction _CmdReadyThreadPrint;
+
 void
 (__cdecl CmdListCpus)(
     IN          QWORD       NumberOfParameters
@@ -129,6 +131,13 @@ void
 
     ASSERT(NumberOfParameters == 0);
 
+
+    DWORD threadsNb;
+
+    GetNumberOfThreads(&threadsNb);
+
+    LOG("Total nb of threads is %U \n", threadsNb);
+
     LOG("%7s", "TID|");
     LOG("%20s", "Name|");
     LOG("%5s", "Prio|");
@@ -137,12 +146,42 @@ void
     LOG("%10s", "Prt ticks|");
     LOG("%10s", "Ttl ticks|");
     LOG("%10s", "Process|");
+    LOG("%11s", "parentTh|");
     LOG("\n");
 
     status = ThreadExecuteForEachThreadEntry(_CmdThreadPrint, NULL );
     ASSERT( SUCCEEDED(status));
 }
 
+
+
+void
+(__cdecl CmdReadyThreads)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    STATUS status;
+
+    ASSERT(NumberOfParameters == 0);
+
+    LOG("%7s", "TID|");
+    LOG("%20s", "Name|");
+    LOG("%5s", "Prio|");
+    LOG("%8s", "State|");
+    LOG("%10s", "Cmp ticks|");
+    LOG("%10s", "Prt ticks|");
+    LOG("%10s", "Ttl ticks|");
+    LOG("%10s", "Process|");
+    LOG("%11s", "parentTh|");
+    LOG("\n");
+
+
+    status = ThreadExecuteForEachThreadEntry(_CmdReadyThreadPrint, NULL);
+    ASSERT(SUCCEEDED(status));
+}
+
+
+
 void
 (__cdecl CmdYield)(
     IN          QWORD       NumberOfParameters
@@ -693,11 +732,44 @@ STATUS
     LOG("%9U%c", pThread->TickCountEarly, '|');
     LOG("%9U%c", pThread->TickCountCompleted + pThread->TickCountEarly, '|');
     LOG("%9x%c", pThread->Process->Id, '|');
+    LOG("%10x%c", pThread->parentTh, '|');
     LOG("\n");
 
     return STATUS_SUCCESS;
 }
 
+static
+STATUS
+(__cdecl _CmdReadyThreadPrint) (
+    IN      PLIST_ENTRY     ReadyList,
+    IN_OPT  PVOID           FunctionContext
+    )
+{
+    PTHREAD pThread;
+
+    ASSERT(NULL != ReadyList);
+    ASSERT(NULL == FunctionContext);
+
+    pThread = CONTAINING_RECORD(ReadyList, THREAD, AllList);
+
+
+    if (pThread->State == ThreadStateReady) {
+
+        LOG("%6x%c", pThread->Id, '|');
+        LOG("%19s%c", pThread->Name, '|');
+        LOG("%4U%c", pThread->Priority, '|');
+        LOG("%7s%c", _CmdThreadStateToName(pThread->State), '|');
+        LOG("%9U%c", pThread->TickCountCompleted, '|');
+        LOG("%9U%c", pThread->TickCountEarly, '|');
+        LOG("%9U%c", pThread->TickCountCompleted + pThread->TickCountEarly, '|');
+        LOG("%9x%c", pThread->Process->Id, '|');
+        LOG("%10x%c", pThread->parentTh, '|');
+        LOG("\n");
+    }
+
+    return STATUS_SUCCESS;
+}
+
 static
 void
 _CmdReadAndDumpCpuid(
diff --git a/src/HAL9000/src/iomu.c b/src/HAL9000/src/iomu.c
index a704910..ae9c84a 100644
--- a/src/HAL9000/src/iomu.c
+++ b/src/HAL9000/src/iomu.c
@@ -28,7 +28,7 @@
 #define PIC_MASTER_OFFSET                   0x20
 #define PIC_SLAVE_OFFSET                    0x28
 
-#define SCHEDULER_TIMER_INTERRUPT_TIME_US   (40*MS_IN_US)
+#define SCHEDULER_TIMER_INTERRUPT_TIME_US   (10*MS_IN_US)
 
 #define HAL9000_SYSTEM_FILE_NAME            "HAL9000.ini"
 
diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
index b311f0c..5727692 100644
--- a/src/HAL9000/src/thread.c
+++ b/src/HAL9000/src/thread.c
@@ -10,9 +10,9 @@
 #include "gdtmu.h"
 #include "pe_exports.h"
 
-#define TID_INCREMENT               4
+#define TID_INCREMENT               0x10
 
-#define THREAD_TIME_SLICE           1
+#define THREAD_TIME_SLICE           4
 
 extern void ThreadStart();
 
@@ -36,10 +36,28 @@ typedef struct _THREAD_SYSTEM_DATA
 
     _Guarded_by_(ReadyThreadsLock)
     LIST_ENTRY          ReadyThreadsList;
+
+    LOCK                 AllThreadsCountLock;
+
+    _Guarded_by_(AllThreadsCountLock)
+    DWORD                AllThreadsCount;
+
 } THREAD_SYSTEM_DATA, *PTHREAD_SYSTEM_DATA;
 
 static THREAD_SYSTEM_DATA m_threadSystemData;
 
+
+STATUS GetNumberOfThreads(
+    INOUT    DWORD* NrThreads
+) {
+    INTR_STATE oldState;
+    LockAcquire(&m_threadSystemData.AllThreadsCountLock, &oldState);
+    *NrThreads = m_threadSystemData.AllThreadsCount;
+    LockRelease(&m_threadSystemData.AllThreadsCountLock, oldState);
+
+    return STATUS_SUCCESS;
+}
+
 __forceinline
 static
 TID
@@ -145,6 +163,9 @@ ThreadSystemPreinit(
 
     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
     LockInit(&m_threadSystemData.ReadyThreadsLock);
+
+    m_threadSystemData.AllThreadsCount = 0;
+    LockInit(&m_threadSystemData.AllThreadsCountLock);
 }
 
 STATUS
@@ -794,11 +815,26 @@ _ThreadInit(
         pThread->State = ThreadStateBlocked;
         pThread->Priority = Priority;
 
+        if (pThread->Id != 0)
+        {
+            PTHREAD pParentThread = GetCurrentThread();
+            if(pParentThread != NULL)
+               pThread->parentTh= pParentThread->Id;
+        }
+
+
         LockInit(&pThread->BlockLock);
 
         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
+
+        LockAcquire(&m_threadSystemData.AllThreadsCountLock, &oldIntrState);
+        m_threadSystemData.AllThreadsCount++;
+        LockRelease(&m_threadSystemData.AllThreadsCountLock, oldIntrState);
+
+
+        LOG("Thread with TID-%d and name-%s has been created\n", pThread->Id, pThread->Name);
     }
     __finally
     {
@@ -1191,6 +1227,13 @@ _ThreadDestroy(
     RemoveEntryList(&pThread->AllList);
     LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
 
+
+    LockAcquire(&m_threadSystemData.AllThreadsCountLock, &oldState);
+    m_threadSystemData.AllThreadsCount--;
+    LockRelease(&m_threadSystemData.AllThreadsCountLock, oldState);
+
+    LOG("Thread with TID-%d has been destroyed\n", pThread->Id);
+
     // This must be done before removing the thread from the process list, else
     // this may be the last thread and the process VAS will be freed by the time
     // ProcessRemoveThreadFromList - this function also dereferences the process
diff --git a/src/shared/kernel/thread.h b/src/shared/kernel/thread.h
index acc7153..db6de6b 100644
--- a/src/shared/kernel/thread.h
+++ b/src/shared/kernel/thread.h
@@ -119,3 +119,8 @@ THREAD_PRIORITY
 ThreadGetPriority(
     IN_OPT  PTHREAD             Thread
     );
+
+STATUS
+GetNumberOfThreads(
+    INOUT    DWORD* NrThreads
+);
\ No newline at end of file
